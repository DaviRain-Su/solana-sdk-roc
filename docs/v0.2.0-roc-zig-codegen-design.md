# v0.2.0 架构设计：Roc 编译到 Solana SBF

## 概述

本文档描述了 Roc on Solana v0.2.0 的架构设计，评估了多种编译路径的可行性。

**更新日期**: 2025-01-04

## 问题背景

### 为什么不能直接使用 Roc → LLVM → SBF？

1. **Roc 捆绑的 LLVM 没有 SBF 支持**
   - Roc 使用 `roc-bootstrap` 提供的预编译 LLVM
   - 该 LLVM 包含 `LLVMBPFCodeGen` 但没有 `LLVMSBFCodeGen`
   - SBF (Solana BPF) 只存在于 Solana 的 LLVM 分支 (`anza-xyz/llvm-project`)

2. **Solana Platform Tools 不包含 LLVM 开发库**
   - `solana-platform-tools` 只包含 LLVM **运行时工具** (clang, llc, lld)
   - **不包含** LLVM 静态库 (libLLVM*.a) - Roc 需要链接这些库
   - 验证命令: `./solana-platform-tools/llvm/bin/llc --version` 显示 SBF 支持
   - 但 `solana-platform-tools/llvm/lib/` 只有 libc.a, libm.a, liblldb.so

3. **LLVM 版本信息**
   - Solana LLVM: 20.1.7-rust-dev
   - Roc 使用的 LLVM: 18.x (通过 roc-bootstrap)

## 方案评估

### 方案 A：构建 Solana LLVM 静态库 (推荐)

**复杂度**: 高 | **时间**: 2-4 小时构建 | **可行性**: ✅ 最完整

需要从源码构建 Solana 的 LLVM，获取静态库：

```bash
# 1. 克隆 Solana 的 Rust 仓库（包含 LLVM）
git clone --single-branch --branch solana-tools-v1.52 \
    --recurse-submodules --shallow-submodules \
    https://github.com/anza-xyz/rust.git solana-rust

# 2. 构建 LLVM（需要 2-4 小时）
cd solana-rust
./build.sh

# 3. 静态库位于:
# solana-rust/build/x86_64-unknown-linux-gnu/llvm/build/lib/libLLVM*.a

# 4. 用该 LLVM 重建 Roc
cd ../roc-source
../solana-zig/zig build roc -Dllvm-path=../solana-rust/build/x86_64-unknown-linux-gnu/llvm/build
```

**优点**:
- 完整的 Roc → LLVM → SBF 路径
- 无需修改 Roc 编译器

**缺点**:
- 构建时间长
- 需要大量磁盘空间 (20+ GB)
- 需要维护和更新

### 方案 B：外部 LLVM 工具链 ❌ 已验证不可行

**复杂度**: 中 | **时间**: 快速 | **可行性**: ❌ 不可行

**2025-01-04 实验结果**:

我们成功将 Roc 生成的 bitcode 编译为 SBF 目标文件：

```bash
# 1. Roc 编译时会在缓存目录生成 bitcode
./roc-source/zig-out/bin/roc build --target=sbfsolana examples/hello-world/app.roc
# 虽然报错，但 bitcode 已生成在 ~/.cache/roc/.../platform_shim_*.bc

# 2. Solana llc 成功编译到 SBF
./solana-platform-tools/llvm/bin/llc -march=sbf -filetype=obj \
    ~/.cache/roc/.../platform_shim_918dd802.bc -o /tmp/test_sbf.o

# 3. 验证 - 生成了有效的 SBF ELF 文件
file /tmp/test_sbf.o
# 输出: ELF 64-bit LSB relocatable, *unknown arch 0x107* (SBF)
```

**但是分析发现根本性问题**:

```
.data 段内容分析:
- Magic: "RSER" (Roc SERialized)
- 包含完整源代码文本 (platform/main.roc, app.roc)
- 包含序列化字节码数据
- roc__main 只是薄包装，调用 roc_entrypoint (需要解释器)
```

**结论**: Roc 的 Zig 编译器使用**序列化解释模式**，不是原生代码生成：
1. ❌ 实际逻辑在序列化字节码中，不在 LLVM IR 中
2. ❌ 需要运行时解释器来执行字节码
3. ❌ 无法在 Solana 上运行解释器（资源限制）

**此方案已排除，请使用方案 A 或 C。**

---

**原始风险评估（供参考）**:
- LLVM IR 版本不兼容 (Roc: 18.x, Solana: 20.x)
- 可能需要修改 Roc 生成的 IR

### 方案 C：Roc → Zig → SBF (长期方案)

**复杂度**: 非常高 | **时间**: 数周 | **可行性**: ✅ 但需大量开发

完全绕过 LLVM，实现 Zig 代码生成器。详见下文。

## 解决方案：Roc → Zig → SBF

### 架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                         app.roc                                 │
│                    (Roc 应用代码)                                │
└─────────────────────────────────────────────────────────────────┘
                               ↓
┌─────────────────────────────────────────────────────────────────┐
│                      Roc 编译器前端                              │
│  • 解析 (Parse)                                                  │
│  • 规范化 (Canonicalize) → CIR                                   │
│  • 类型检查 (Type Check)                                         │
│  • 类型推断 (Type Inference)                                     │
└─────────────────────────────────────────────────────────────────┘
                               ↓
                    CIR (Canonical IR) + 类型信息
                               ↓
┌─────────────────────────────────────────────────────────────────┐
│                   Zig 代码生成器 (新组件)                         │
│  • CIR 表达式 → Zig 代码                                         │
│  • Roc 类型 → Zig 类型                                           │
│  • 引用计数插入 (Perceus)                                         │
│  • 与 host.zig 集成                                              │
└─────────────────────────────────────────────────────────────────┘
                               ↓
                         generated.zig
                               ↓
┌─────────────────────────────────────────────────────────────────┐
│                      solana-zig 编译                             │
│  (已在 v0.1.0 验证可工作)                                         │
└─────────────────────────────────────────────────────────────────┘
                               ↓
                         roc-hello.so
                        (SBF 字节码)
```

## CIR 表达式到 Zig 的映射

### 1. 字面量

| Roc CIR | Zig 代码 |
|---------|----------|
| `e_num { value: 42, kind: .i64 }` | `const x: i64 = 42;` |
| `e_str_segment { literal: "hello" }` | `const s = "hello";` |
| `e_list { elems: [...] }` | `var list = RocList.init(...);` |
| `e_record { fields: [...] }` | `const rec = .{ .field1 = v1, ... };` |
| `e_tuple { elems: [...] }` | `const tup = .{ v1, v2, ... };` |
| `e_empty_list` | `RocList.empty()` |
| `e_empty_record` | `.{}` |

### 2. 控制流

| Roc CIR | Zig 代码 |
|---------|----------|
| `e_if { branches, final_else }` | `if (cond) expr1 else expr2` |
| `e_match { ... }` | `switch (value) { ... }` |
| `e_block { stmts, final_expr }` | `{ stmt1; stmt2; expr }` |
| `e_for { patt, expr, body }` | `for (items) \|item\| { body }` |

### 3. 函数和调用

| Roc CIR | Zig 代码 |
|---------|----------|
| `e_lambda { args, body }` | `fn(args) T { body }` |
| `e_closure { captures, ... }` | 闭包结构体 + 函数指针 |
| `e_call { func, args }` | `func(arg1, arg2, ...)` |
| `e_lookup_local { pattern_idx }` | 变量名 |

### 4. 标签联合

| Roc CIR | Zig 代码 |
|---------|----------|
| `e_tag { name: "Ok", args: [v] }` | `.{ .Ok = v }` |
| `e_zero_argument_tag { name: "None" }` | `.None` |

### 5. 二元/一元操作

| Roc CIR | Zig 代码 |
|---------|----------|
| `e_binop { op: .add, ... }` | `a + b` |
| `e_binop { op: .eq, ... }` | `a == b` |
| `e_unary_minus { expr }` | `-expr` |
| `e_unary_not { expr }` | `!expr` |

## Roc 类型到 Zig 类型的映射

### 基础类型

| Roc 类型 | Zig 类型 |
|----------|----------|
| `U8`, `I8` | `u8`, `i8` |
| `U16`, `I16` | `u16`, `i16` |
| `U32`, `I32` | `u32`, `i32` |
| `U64`, `I64` | `u64`, `i64` |
| `U128`, `I128` | `u128`, `i128` |
| `F32`, `F64` | `f32`, `f64` |
| `Dec` | `RocDec` (自定义类型) |
| `Str` | `RocStr` |
| `Bool` | `bool` |

### 复合类型

| Roc 类型 | Zig 类型 |
|----------|----------|
| `List a` | `RocList(T)` |
| `{ field1: T1, field2: T2 }` | `struct { field1: T1, field2: T2 }` |
| `(T1, T2, T3)` | `struct { @"0": T1, @"1": T2, @"2": T3 }` |
| `[Ok T, Err E]` | `union(enum) { Ok: T, Err: E }` |

## 低级操作实现

Roc 的 `e_low_level_lambda` 操作需要在 Zig 中实现：

```zig
// src/roc_builtins.zig

pub const RocStr = struct {
    bytes: [*]const u8,
    len: usize,
    
    pub fn isEmpty(self: RocStr) bool {
        return self.len == 0;
    }
    
    pub fn concat(self: RocStr, other: RocStr) RocStr {
        // 实现字符串连接
    }
    
    // ... 其他字符串操作
};

pub fn RocList(comptime T: type) type {
    return struct {
        ptr: [*]T,
        len: usize,
        cap: usize,
        
        pub fn isEmpty(self: @This()) bool {
            return self.len == 0;
        }
        
        pub fn get(self: @This(), idx: usize) ?T {
            if (idx >= self.len) return null;
            return self.ptr[idx];
        }
        
        // ... 其他列表操作
    };
}
```

## 引用计数 (Perceus 算法)

Roc 使用 Perceus 算法进行自动内存管理。在 Zig 代码生成中需要：

1. **引用计数字段**：在堆分配的结构体中添加引用计数
2. **增引用**：在值被复制时增加计数
3. **减引用**：在值离开作用域时减少计数
4. **释放**：当计数归零时释放内存

```zig
pub fn RocBox(comptime T: type) type {
    return struct {
        const Header = struct {
            refcount: usize,
        };
        
        ptr: *T,
        
        pub fn incref(self: @This()) void {
            const header = @ptrCast(*Header, @ptrFromInt(@intFromPtr(self.ptr) - @sizeOf(Header)));
            _ = @atomicRmw(usize, &header.refcount, .Add, 1, .monotonic);
        }
        
        pub fn decref(self: @This()) void {
            const header = @ptrCast(*Header, @ptrFromInt(@intFromPtr(self.ptr) - @sizeOf(Header)));
            if (@atomicRmw(usize, &header.refcount, .Sub, 1, .monotonic) == 1) {
                // 释放内存
                allocator.destroy(self.ptr);
            }
        }
    };
}
```

## 与 host.zig 集成

生成的 Zig 代码需要与现有的 `src/host.zig` 集成：

```zig
// src/host.zig (现有)
const sdk = @import("solana-program-sdk-zig");

// 导入生成的 Roc 代码
const roc_app = @import("generated.zig");

export fn entrypoint(input: [*]u8) u64 {
    // 调用 Roc 应用的 main 函数
    const result = roc_app.main();
    
    // 处理结果
    switch (result) {
        .Ok => return 0,
        .Err => |err| {
            sdk.log.log(err.message);
            return 1;
        },
    }
}
```

## 实现步骤

### 阶段 1：基础设施 (1-2 周)

1. [ ] 创建 `src/codegen/zig_emitter.zig` - Zig 代码生成器骨架
2. [ ] 实现基础类型映射 (数字、布尔、字符串)
3. [ ] 实现简单字面量生成

### 阶段 2：表达式生成 (2-3 周)

1. [ ] 实现二元/一元操作
2. [ ] 实现控制流 (if/match/block)
3. [ ] 实现函数调用
4. [ ] 实现局部变量查找

### 阶段 3：复杂类型 (2-3 周)

1. [ ] 实现列表类型和操作
2. [ ] 实现记录类型和字段访问
3. [ ] 实现元组类型
4. [ ] 实现标签联合

### 阶段 4：闭包和引用计数 (2-3 周)

1. [ ] 实现闭包捕获
2. [ ] 实现 Perceus 引用计数
3. [ ] 实现内存分配集成

### 阶段 5：集成和测试 (1-2 周)

1. [ ] 与 host.zig 集成
2. [ ] 端到端测试
3. [ ] 性能优化

## 替代方案评估

| 方案 | 优点 | 缺点 |
|------|------|------|
| **Roc → Zig → SBF** (本方案) | 利用现有 solana-zig 工具链，无需修改 LLVM | 需要实现 Zig 代码生成器 |
| Roc → LLVM → SBF | 完整的 Roc 编译路径 | 需要维护 Solana LLVM 分支 |
| Roc 解释器 | 无需编译 | 无法在 Solana 上运行 |

## 风险和缓解

| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| Roc CIR 变化 | 中 | 保持代码生成器模块化，易于更新 |
| Zig 版本兼容性 | 低 | 使用 solana-zig 固定版本 |
| 性能问题 | 中 | 优化热路径，使用 Zig 内联 |
| 引用计数开销 | 中 | 利用 Perceus 的静态分析减少运行时检查 |

## 结论与推荐路径

### 短期推荐：方案 A（构建 Solana LLVM）

对于快速验证 Roc → SBF 编译路径，推荐方案 A：

1. **一次性投入**：2-4 小时构建时间
2. **完整路径**：无需修改 Roc 编译器
3. **验证可行性**：确认 Roc 能正确生成 SBF 代码

### 长期推荐：方案 C（Zig 代码生成）

对于生产级解决方案，推荐方案 C：

1. **可维护性**：不依赖 LLVM 版本
2. **可控性**：完全掌控代码生成
3. **可扩展性**：可以针对 Solana 优化

## 下一步行动

### 立即执行（方案 A 验证）

```bash
# 1. 克隆 Solana Rust（包含 LLVM）
cd /home/davirain/dev/solana-sdk-roc
git clone --single-branch --branch solana-tools-v1.52 \
    --recurse-submodules --shallow-submodules \
    https://github.com/anza-xyz/rust.git solana-rust

# 2. 构建（在后台运行，需要 2-4 小时）
cd solana-rust
nohup ./build.sh > build.log 2>&1 &

# 3. 监控进度
tail -f build.log
```

### 构建完成后

```bash
# 获取 LLVM 路径
LLVM_PATH=/home/davirain/dev/solana-sdk-roc/solana-rust/build/x86_64-unknown-linux-gnu/llvm/build

# 用 Solana LLVM 重建 Roc
cd ../roc-source
../solana-zig/zig build roc -Dllvm-path=$LLVM_PATH

# 测试 SBF 编译
./zig-out/bin/roc build ../examples/hello-world/app.roc --target=sbfsolana
```

## 相关资源

- [Solana Platform Tools](https://github.com/anza-xyz/platform-tools)
- [Solana LLVM Fork](https://github.com/anza-xyz/llvm-project)
- [Roc Bootstrap](https://github.com/roc-lang/roc-bootstrap)
- [v0.1.0 Story](../stories/v0.1.0-hello-world.md) - Zig 宿主已验证工作
