# Story: v0.2.0 真正的 Roc 集成

> 将 Roc 编译器输出真正集成到 Solana 程序中，实现 Roc 代码在链上执行

## 目标

1. 将 Roc 应用编译为 LLVM 位码
2. 将 Roc 位码与 Zig 宿主链接
3. 实现完整的 Roc → Solana 编译流程
4. 验证 Roc 代码在链上正确执行

## 技术方案

### 编译流程

```
examples/hello-world/app.roc
    ↓ roc build --lib --no-link
app.o (Roc 对象文件)
    ↓ 
src/host.zig + app.o
    ↓ zig build solana
combined.bc (LLVM 位码)
    ↓ sbpf-linker
roc-hello.so (Solana eBPF)
    ↓ solana program deploy
链上程序
```

### 架构

```
┌─────────────────────────────────────┐
│    examples/hello-world/app.roc     │ ← Roc 应用 (纯函数式)
│    main = "Hello from Roc!"         │
└─────────────────────────────────────┘
                 ↓ roc build --lib
┌─────────────────────────────────────┐
│         platform/main.roc           │ ← Roc 平台定义
│    requires { main : Str }          │
│    provides [mainForHost]           │
└─────────────────────────────────────┘
                 ↓
┌─────────────────────────────────────┐
│         src/host.zig                │ ← Zig 宿主
│    roc_alloc, roc_panic, etc.       │
│    调用 roc__mainForHost            │
└─────────────────────────────────────┘
                 ↓
┌─────────────────────────────────────┐
│    vendor/solana-program-sdk-zig    │ ← Solana SDK
│   (allocator, log, syscalls)        │
└─────────────────────────────────────┘
```

## 验收标准

### 前置条件
- [x] 安装 Roc 编译器 (nightly)
- [x] 验证 Roc 能编译 platform/main.roc

### platform/main.roc
- [x] 定义正确的平台接口 (requires, exposes, provides)
- [x] 导出 mainForHost 函数
- [x] 通过 Roc 编译器验证

### src/host.zig
- [x] 声明 extern fn roc__mainForHost_1_exposed_generic
- [x] 在 entrypoint 中调用 Roc 的 mainForHost
- [x] 获取 Roc 返回的字符串并输出到日志
- [x] RocStr ABI 匹配 (16 字节: ptr + u32 len + u32 cap)

### examples/hello-world/app.roc
- [x] 正确引用平台
- [x] 返回自定义字符串
- [x] 通过 Roc 编译器验证

### build.zig
- [x] 添加 Roc 编译步骤 (scripts/compile-roc.sh)
- [x] 链接 Roc 生成的对象文件
- [ ] **[阻塞]** sbpf-linker 多文件链接失败

### 测试和部署
- [x] Roc 编译成功 (roc build --emit-llvm-ir)
- [x] Roc → BPF 对象文件成功 (llc-18 -march=bpfel)
- [x] Zig 构建成功 (zig build test)
- [ ] **[阻塞]** 生成有效的 BPF 字节码 (zig build solana)
- [ ] 部署到本地测试网成功
- [ ] 调用程序并验证日志输出来自 Roc 代码

### 文档
- [ ] 更新 README.md
- [ ] 更新 docs/build-integration.md

## 完成状态

- 开始日期: 2026-01-03
- 完成日期: -
- 状态: ⏳ 进行中 (阻塞于链接问题)

## 挑战和解决方案

### 挑战 1: Roc 不支持 BPF 目标
- Roc 只支持: linux-x64, linux-arm64, macos-x64, macos-arm64, wasm32
- **解决**: 用 `roc build --emit-llvm-ir` 生成 IR，然后:
  1. opt-18 优化
  2. sed 修改 target triple 和 datalayout
  3. awk 过滤只保留需要的函数
  4. llc-18 -march=bpfel 编译为 BPF 对象

### 挑战 2: BPF 不支持复杂操作
- BPF 不支持 128 位整数运算 (__divti3, __muloti4 等)
- BPF 不支持浮点运算 (floorf, __addsf3 等)
- BPF 不支持聚合类型返回 (sret)
- **解决**: 从 IR 中过滤掉所有运行时支持函数，只保留 roc__* 函数

### 挑战 3: LLVM 版本不兼容
- Zig 0.15 使用 LLVM 20
- 系统安装 LLVM 18
- llvm-link 无法合并不同版本的 bitcode
- **解决**: 不使用 llvm-link，直接让 sbpf-linker 链接多个文件

### 挑战 4: sbpf-linker 多文件链接问题 [当前阻塞]
- 错误: "Relocations found but no .rodata section"
- 问题出在 Zig host bitcode，不是 Roc 对象
- 即使单独链接 host bitcode 也报错
- **待解决**: 需要探索替代链接策略

### 挑战 5: 内存分配器 [已解决]
- Solana 有 32KB 堆限制
- Roc 使用引用计数 (Perceus)
- **已解决**: 在 v0.1.0 实现使用 Solana bump allocator

## 下一步 (v0.3.0)

- [ ] 支持 Roc 效果系统映射到 Solana syscalls
- [ ] 实现账户操作 (读取/写入账户数据)
- [ ] 支持 CPI (跨程序调用)
